#fault(0) refers to your first indexed fault, fault(1) refers to your second indexed fault
#All distances in km (unless otherwise specfied), all angles in degrees, all coordinates in decimal form


#The following parameters are used to begin/initialize a chain.
#All these values should remain at 'None' or '0'. However, fault_idx may be ommitted if you are sampling over a single fault...
#... similarly, the offsets can be ommitted depending on how much uncertainty is present in the data for your fault(s)
[init]              
method = 'manual'   #Specifies how the initial sample will be created. 'manual'--user-defined input for first sample, 'prior_rvs'--program will randomly generate a starting point.
latitude = None     #Latitude coordinate for the sample (in decimal)
longitude = None    #Longitude coordinate
magnitude = None    #Magnitude (Richter Scale)
delta_logl = 0.0
delta_logw = 0.0
depth_offset = 0.0  #Each lat/lon point is associated with a given depth, but this may not be the exact depth of the epicenter. Specify the offset from the default depth level.
dip_offset = 0.0    #Specify how much offset from the default dip at the lat/lon point.
strike_offset = 0.0 #Specify how much offset from the default strike at the lat/lon point.
rake_offset = 0.0   #Specify how much offset from the default rake at the lat/lon point.
#fault_idx = None    #When sampling over multiple faults, specify one as index (0) and the other as index (1). Then specify on which fault your initial sample lies.
                    
#The proposal kernel specifies the standard deviations for each parameter (as specified above) to be used in the
#...MCMC random walk. These values are determined based on consultation with geologist for each specific fault & testing of chains to 
#...see how fully they covered the sample space.
#The given values were the values used for the Flores fault (Sulawesi 1820 event) proposal kernel
[proposal_kernel]   
lat_std_fault = 0.075
lon_std_fault = 0.075
mag_std_fault = 0.075
delta_logl_std_fault = 0.01
delta_logw_std_fault = 0.01
depth_offset_std_fault  = 0.5
dip_offset_std_fault = 3.5
rake_offset_std_fault = 5.5
strike_offset_std_fault = 5.0

#A second set of kernel values may be included for fault1, if sampling with 2 faults.

#The model bounds specify the rectangular region over which you will be modeling the tsunamis.
[model_bounds]  
lat_min = 0   #Specify the interval over the latitude axis. (- is South of equator, + is North of equator)
lat_max = 23
lon_min = 79   #...and the longitudinal axis                 (- is West of Prime Meridian, + is East of Prime Meridian)
lon_max = 101  #Be sure this rectangular regions include all the faults & observation locations with some buffer on each side...
                #...However, the larger the region for the simulation, the longer each sample will take because Geoclaw must simulate the wave over the entire area.


#This section specifies the folder paths where the fault data is stored.
#For the format of the .npz & .pkl files see ___________________
[fault]                                             
fault_data_path = 'data/sumatra_fault_data.npz'     #THe path of the .npz file, stored in the data file. (.npz) files are used when Slab2 data is availabe.
#fault1_data_path = 'data/walanae_fault_data.pkl'    #"""" .pkl files are used when the fault's data is estimated from Gaussian Processes

#The following prior values are determined from consultation with a Geologist to estimate the realistic earthquake parameters.
#The given values were used in the Sulawesi 1820 event for the flores fault. Your values will be different.
[prior]                 #This section specifies the parameters for the prior distribution (means, standard deviations, & mins/maxes)
                        #See https://docs.scipy.org/ for normal, truncated normal, and truncated exponential objects.
                        #All depths are in km.
                        #mu (mean) and std (standard deviation) parameters are for normal probability distribution objects.
                        #'min' & 'max' values are used for truncated normal objects.
                        #'b' & 'loc' parameters are used for a truncated exponential continuous random variable.
depth_mu_fault = 31886    #Consult data from Gaussian Process regression & Geologist to specify the mean & standard deviation.
depth_std_fault = 7163 #>>>> use spreadshift and get their std
mindepth_fault = 2500            #Minimum depth for which tsunamis are possible for given fault (consult geologist)
maxdepth_fault = 35000             #Maximum depth for which tsunamis are possible


mag_b_fault = 3           #Parameters for truncated exponential continuous random variable for fault magnitude.
mag_loc_fault = 6.5       #For precise details of the meaning of 'b' and 'loc', see: https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.truncexpon.html

delta_logl_std_fault = 0.188
delta_logw_std_fault = 0.172
                                #An offset is specified from each sample, the following parameters define probability distributions for these offsets. Each of these distributions have a mean of 0.
depth_offset_std_fault = 7163   #Depth offset standard deviation for fault; >>>> use spreadshift and get their std
dip_offset_std_fault = 82.0   #Dip offset standard deviation for fault
rake_offset_std_fault = 13.0   #Rake offset standard deviation for fault
strike_offset_std_fault = 36.0  #Strike offset standard deviation for fault


#The following section specifies file paths & settings for the tsunami wave modeling package, 'Geoclaw'
[geoclaw]                       
dtopo_path = 'dtopo.tt3'        #Specify the file name of the bathymetry dat for the entire region (should match lat/lon area specified in "model_bounds")
topo_dir = 'data/topo/'         #Specify the file path for the topography data
refinement_ratios = [2,2,2,3,5] #The progression of refinement ratios (think step size of numerical methods in wave equations)
run_time = 10800.0               #The amount of time you wish the model to run (in sec). Usually this should be 30min-1hour longer than your latest arrival time observation.
xcoarse_grid = 220               #The number of grid divisions (east-west) for the first level of refinement. Value = 10* (lon_max - lon_min)
ycoarse_grid = 230               #North-south grid divisions. Value = 10* (lat_max - lat_min)
verbosity = 1                   #Turn Geoclaw's verbose output on or off
adjoint_outdir = '/fslgroup/fslg_tsunami/adjoint_output/sumatra_2004'  #Specify the file output for the adjoint directory NEED DR. W FOR

#This section specifies where the output files for the wave information at each gauge will be saved
[fgmax]                             
fgmax_grid_path = 'fgmax_grid.txt'  #Path for the ___ file
valuemax_path = 'fort.FG1.valuemax'
aux1_path = 'fort.FG1.aux1'
tstart_max = 10.0                   #This is the lower limit of wave arrival times that will be considered 'valid'
tend_max = 1.0e10                   #This is the upper limit of wave arrival times.
dt_check = 0.0                      #Checks every time step
arrival_tol = 1.5                   #This is the minimum wave height that will be detected (in meters).


#The following section defines the regions over which Geoclaw needs to compute the wave equations the most precisely.
#These regions correspond to small areas surrounding the coast at the gauge location, large enough to capture any variation in the actual..
#...gauge location "pin".
#Format of regions: all values in either seconds or degrees (dec). Regions must be rectangular, hence, the lat/lon points specify the top-left and bottom-right corners of the region.
# [time to start highest level refinement (usually 0), time to end highest refiniment (usually the same value as tend_max in [fgmax], unless arrival time for a gauge is much larger than other gauges)...
#...left_side longitude, right_side longitude, upper_side lattidue, lower_side lattitude]
#If coastline near gague is obstructed by islands/irregularites, a larger region is needed. To minimize necessary computation time...
#...these regions can be split up into smaller rectangels to minimize unecessary area (such as on land or less-useful ocean areas)
#If coastlines near gauges location is fairly open/smooth, only one region is needed per gauge.
[regions]
region1 = [0,1.e10, 98.7468, 98.8086, 7.797, 7.7067] # Phi Phi, Thailand

region2 = [0,1.e10, 98.2371, 98.2559, 8.6758, 8.6353] # Khao Lak, Thailand

region3 = [0,1.e10, 98.2637, 98.3196, 8.2007, 7.9988] #Northwest Phuket, Thailand
region4 = [0,1.e10, 98.255, 98.315, 7.9988, 7.736] #Southwest Phuket, Thailand
region5 = [0,1.e10, 98.315, 98.45, 7.86, 7.736] #Southeast Phuket, Thailand
region6 = [0,1.e10, 98.39, 98.47, 8.12, 7.86] #Notheast Phuket, Thailand

region7 = [0,1.e10, 95.2669, 95.4115, 5.6563, 5.5543] #Banda Aceh, Indonesia

region8 = [0,1.e10, 80.063, 80.1047, 6.1818, 6.1422] #Telwatta, Sri Lanka

region9 = [0,1.e10, 81.1881, 81.2709, 8.6181, 8.5267] #Trincomalee, Sri Lanka

region10 = [0,1.e10, 91.7075, 91.8411, 22.4136, 22.2154] #Chittagong, Bangladesh

region11 = [0,1.e10, 91.9319, 92.0161, 21.5113, 21.3657] #Cox's Bazar, Bangladesh

region12 = [0,1.e10, 79.823, 79.8969, 12.0726, 11.9096] #Puducherry, India

region13 = [0,1.e10, 100.1624, 100.4425, 5.5877, 5.33] #North Penang, Malaysia
region14 = [0,1.e10, 100.1624, 100.4425, 5.33, 5.1089] #South Penang, Malaysia